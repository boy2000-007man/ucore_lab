练习1：分配并初始化一个进程控制块
---
设计实现过程
```
首先清空申请到的PCB,将其全部置0
然后再设置state,pid,cr3的初始值
```
```
context用于保存调度进程时的上下文信息
tf则是指向中断发生时记录进程被中断前状态的中断帧的指针
在本实验中context的作用是保存进程切换时部分数据寄存器和指针寄存器,变址寄存器,指令指针寄存器的信息
而tf则是保存进程的段寄存器,部分数据寄存器和指令指针寄存器
```
练习2：为新创建的内核线程分配资源
---
设计实现过程
```
先申请分配一个PCB
再对应设置其内核栈,内存管理器,相关上下文,中断帧指针,父亲
如出现错误则跳转到相应的处理语句
之后是原子操作
设置唯一pid,加入到hash链表和进程链表中,增加进程计数
接着唤醒进程
设置返回值ret为进程pid
```
```
ucore做到了给每个新fork的线程一个唯一的id
因为get_pid函数通过不停扫描已存在进程的pid来获得并返回一个不重复的pid,而且由于是在原子操作时完成的,不用担心出现冲突
```
练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的
---
```
共创建并运行了两个进程:
pid=0的idleproc线程和pid=1的initproc线程
语句local_intr_save和local_intr_restore在这里保证进程切换时,进程的上下文信息以及记录当前运行进程的变量正确的存储和还原,而不被外界的因素所干扰,因为它屏蔽了中断,确保了当前进程对CPU的独占,从而起到保护原子操作的作用
```